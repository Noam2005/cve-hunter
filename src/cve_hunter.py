import argparse
import json
import requests
from colorama import Fore, Style
from typing import Dict, Any, List, Tuple
from tqdm import tqdm

START_MSG = Fore.GREEN + "The scan is starting.\n" + Style.RESET_ALL + \
    Fore.YELLOW + "Please be aware that it may take a while, especially if " \
    "there are many dependencies or dependencies with many CVEs.\n" \
    "It is also important to note that pressing ^c will not guarantee a full or partial scan " \
    "of the current dependency being scanned." + Style.RESET_ALL


def parse_requirements_file(filename: str) -> List[Tuple[str, str]]:
    """
    function to parse requirements file

    Args:
        filename (str): the path to the requirments file

    Returns:
        List[Tuple[str, str]]: list of packages and versions
    """
    with open(filename, 'r') as f:
        lines = f.readlines()
    dependencies = []
    for line in lines:
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        parts = line.split('==')
        if len(parts) != 2:
            continue
        dependencies.append((parts[0], parts[1]))
    return dependencies


def parse_package_json_file(filename: str) -> List[Tuple[str, str]]:
    """
    function to parse package.json file

    Args:
        filename (str): the path to the package.json file

    Returns:
        List[Tuple[str, str]]: list of packages and versions
    """
    with open(filename, 'r') as f:
        data = json.load(f)
    dependencies = []
    if 'dependencies' in data:
        for dep_name, dep_ver in data['dependencies'].items():
            dependencies.append((dep_name, dep_ver))
    return dependencies


def query_cve_database(dep_name: str, dep_ver: str, ecosystem: str = 'PyPI') -> Dict[Any, Any]:
    """
    function that search for CVEs

    Args:
        dep_name (str): the name of the dependency
        dep_ver (str): the version of the dependency
        ecosystem (str, optional): the ecosystem that the dependency belong to. can be PyPI or npm.
                                    Defaults to 'PyPI'.

    Returns:
        Dict[Any, Any]: the dictionary of the CVE information, if CVE was found, is look like this:
                        {CVE_ID: {'fixed': fixed, 'dep_ver': package_version, 'dep_name': package_name}}.
                        if CVE was not found, returns empty dict 
    """
    if ecosystem != 'PyPI' and ecosystem != 'npm':
        raise Exception("Error: unsupported ecosystem")
    url = f'https://api.osv.dev/v1/query'
    headers = {
        "Content-Type": "application/json"
    }

    data = {
        "version": dep_ver,
        "package": {
            "name": dep_name,
            "ecosystem": ecosystem
        }
    }

    response = requests.post(url, headers=headers, data=json.dumps(data))

    data = json.loads(response.text)

    cves = {}
    try:
        for vuln in data["vulns"]:
            for (alias, affected) in zip(vuln["aliases"], vuln['affected']):
                for range in affected['ranges']:
                    if "events" in range:
                        for events in range['events']:
                            fixed = events['fixed'] if "fixed" in events else None
                            # sometimes it puts the same CVE fixed version twice, one with None as fixed and
                            # one with the fixed version, this condition is to avoid it
                            if alias in cves and fixed is None and cves[alias] is not None:
                                pass
                            else:
                                cves[alias] = {
                                    'fixed': fixed, 'dep_ver': dep_ver, 'dep_name': dep_name}
        return cves
    except KeyError:
        # return cves, usually it will be empty but sometimes it will not so it safer like that
        return cves
    except KeyboardInterrupt:
        # return the cves collected until the keyboard interrupt
        return cves
    except Exception as e:
        # if another exception occured, print it and return empty dict
        print(e)
        return {}


def parse() -> Dict[str, List[Tuple[str, str]]]:
    """
    function that parse the arguments

    Returns:
        Dict[str, List[Tuple[str, str]]]: the parsed file
    """
    parser = argparse.ArgumentParser(
        description='''This program helps you find open CVEs (Common Vulnerabilities and Exposures) in your project dependencies.
        Note that if the program takes a long time to run, it may be because you have dependencies with many CVEs.'''
    )
    parser.add_argument('-r', dest='req_file',
                        help='path to requirements.txt file')
    parser.add_argument('-p', dest='pkg_file',
                        help='path to package.json file')
    args = parser.parse_args()

    if not args.req_file and not args.pkg_file:
        parser.error(
            '''Please specify either a requirements.txt file or a package.json file.''')
    if args.req_file and args.pkg_file:
        parser.error(
            'Please specify either a requirements.txt file or a package.json file, not both.')
    if args.req_file:
        return {'data': parse_requirements_file(args.req_file), 'ecosystem': 'PyPI'}
    else:
        return {'data': parse_package_json_file(args.pkg_file), 'ecosystem': 'npm'}


def main():
    print(START_MSG)
    dependencies = parse()
    cves = []
    try:
        # use tqdm for progress bar
        for dep in tqdm(dependencies.get('data'), leave=False):
            cves.append(query_cve_database(
                dep[0], dep[1], dependencies.get('ecosystem')))
    except KeyboardInterrupt:
        print("Scan stopped")
    except Exception as e:
        print(e)
    finally:
        # check if cves list if empty or contain only empty dicts,
        # if yes that means no vulnerabilities were found, otherwise it means that
        # vulnerabilities were found
        if all(not d for d in cves):
            print("No vulnerabilities were found.")
        else:
            print('Dependency Name           | Current Dependency Version  | CVE ID \
                    | Fix version')

            print('-' * 100)
            for cve in cves:
                for key, value in cve.items():
                    print(
                        f"{value.get('dep_name').ljust(25)} | {value.get('dep_ver').ljust(27)} | {key.ljust(26)} | {value.get('fixed').ljust(10)}")


if __name__ == "__main__":
    main()
